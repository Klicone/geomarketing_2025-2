---
title: "Caracterización de la población del Gran Santiago"
subtitle: "Clusters basados en tenencia de vivienda e ingresos"
author: "Kevin Licón Esparza"
date: "`r Sys.Date()`"
output: html_document
---

# 1. Introducción

::: {style="text-align: justify;"}
El presente trabajo se desarrolla como continuación directa del proceso iniciado en el Trabajo 2, donde se realizó una microsimulación con el propósito de estimar la tenencia de vivienda a nivel de zona censal en el Gran Santiago. Este ejercicio permitió generar una variable sintética a partir de la proporción de viviendas arrendadas y proporción de viviendas propias, construida a partir de microdatos del Censo 2017 y de la CASEN 2022.

En el marco de esta entrega, el trabajo tiene por objetivo utilizar dicha variable microsimulada como insumo principal para la aplicación de técnicas de agrupamiento. En particular, se implementa el algoritmo k-means con el fin de identificar conjuntos de zonas censales que compartan características similares. Para ello, además de la variable de tenencia generada previamente, se incorporan otras variables microsimuladas y, además, otras complementarias provenientes del Censo 2017.

Además de caracterizar la estructura interna de los grupos resultantes, este trabajo busca comparar el comportamiento de la variable microsimulada de tenencia con la combinación de variables seleccionada para el clustering. La intención es observar en qué medida la variable principal se alinea, se dispersa o adquiere nuevas formas de agrupamiento cuando es analizada junto a indicadores socioeconómicos complementarios.
:::

# 2. Objetivos

## 2.1 Objetivo General

::: {style="text-align: justify;"}
Aplicar técnicas de agrupamiento k-means para clasificar las zonas censales del Gran Santiago utilizando como insumo principal la variable de tenencia de vivienda microsimulada, incorporando variables complementarias del Censo 2017 para comparar su comportamiento conjunto.
:::

## 2.2 Objetivos Específicos

-   Integrar la variable microsimulada con los indicadores seleccionados y preparar la base para el análisis.

-   Determinar el número adecuado de clusters y ejecutar el algoritmo k-means sobre las variables estandarizadas.

-   Visualizar las relaciones entre las variables utilizadas y los clusters obtenidos.

-   Comparar la variable microsimulada con la estructura resultante del clustering.

# 3. Metodología

## 3.1 Librerías

Para la realización del trabajo se utilizó como entorno de programación R (versión 4.5.1), complementado con un conjunto de librerías que permiten la conexión a bases de datos, manipulación de datos espaciales, microsimulación y visualización estadística.

```{r librerias, echo=TRUE, message=FALSE, warning=FALSE}
library(factoextra)
library(ggfortify)
library(plotly)
library(DBI)
library(RPostgres)
library(sf)
library(ggplot2)
library(cowplot)
library(GGally)
library(dplyr)
library(tidyr)
```

Estas herramientas permiten obtener un flujo de análisis más acabado.

## 3.2 Entradas

Para el desarrollo del análisis de utilizaron dos capas geoespaciales procesadas previamente y almacenadas en formato GeoJSON:

-   `zonas_gs_ingreso.geojson` : contiene la mediana de ingreso microsimulada por zona censal del Gran Santiago.

-   `zonas_gs_tenencia.geojson` : contiene las proporciones de tenencia de vivienda microsimulada por zona censal del Gran Santiago.

Ambas capas fueron importadas mediante la función `st_read()` del paquete **sf**. Además, se estableció una conexión con la base de datos PostgreSQL, desde la cual se extrajeron dos indicadores derivados del censo 2017.

```{r entradas, message=FALSE, warning=FALSE, include=FALSE}
zonas_gs_ingreso = st_read("../../output/zonas_gs_ingreso.geojson")
zonas_gs_tenencia = st_read("../../output/zonas_gs_tenencia.geojson")
```

```{r conexion DB, message=FALSE, warning=FALSE, include=FALSE}
## Conexión a BD

# Definir parámetros de conexión
db_host     = "localhost"       # servidor de BD
db_port     = 5432                # puerto de escucha
db_name     = "censo_rm_clases"   # nombre de la base
db_user     = "postgres"        # usuario de conexión
db_password = "postgres"        # clave de usuario

# Establecer conexión usando RPostgres
con = dbConnect(
  Postgres(),
  dbname   = db_name,
  host     = db_host,
  port     = db_port,
  user     = db_user,
  password = db_password
)
```

```{r Query extraccion, echo=TRUE, message=FALSE, warning=FALSE}
sql_indicadores = "
SELECT
  z.geocodigo AS geocodigo,
  c.nom_comuna,
  
  -- Años promedio de escolaridad para personas de 18+ años
  ROUND(
    AVG(p.escolaridad) FILTER (WHERE p.p09 >= 18 AND p.escolaridad IS NOT NULL),
    2) AS promedio_escolaridad_18mas,
  
  -- Promedio de personas por hogar en la zona
  ROUND(
    COUNT(*)::numeric
    / NULLIF(COUNT(DISTINCT h.hogar_ref_id), 0),
    2) AS promedio_personas_por_hogar

FROM public.personas   AS p
JOIN public.hogares    AS h ON p.hogar_ref_id    = h.hogar_ref_id
JOIN public.viviendas  AS v ON h.vivienda_ref_id = v.vivienda_ref_id
JOIN public.zonas      AS z ON v.zonaloc_ref_id  = z.zonaloc_ref_id
JOIN public.comunas    AS c ON z.codigo_comuna   = c.codigo_comuna

GROUP BY z.geocodigo, c.nom_comuna
ORDER BY promedio_escolaridad_18mas DESC;
"
```

Los indicadores obtenidos para cada zona censal a partir de la query fueron:

a) Promedio de escolaridad (18+)

Este indicador corresponde al promedio de los años de escolaridad reportados por las personas censadas que cumplen:

-   tener 18 años o más (variable `p09` $\geq$ 18).

-   poseer un valor no nulo en escolaridad.

La fórmula aplicada para cada zona censal $z$ es:

$$
\text{EscolaridadProm}_{z} =\frac{\sum_{i \in z,\, p09_i \ge 18} \text{escolaridad}_i}{N_{z,\;18+}}\
$$

donde $N_{z, 18+}$ es el número de personas mayores de edad en la zona. De aquí se obtiene la variable `promedio_scolaridad_18mas`.

b) Promedio de personas por hogar

El censo permite identificar hogares y sus integrantes. El indicador se construye como:

$$
\text{PersonasHogar}_{z} =\frac{N_{\text{personas},\,z}}{N_{\text{hogares},\,z}}
$$

Luego la variable es nombrada como `promedio_personas_por_hogar`.

```{r dataframe indicadores, message=FALSE, warning=FALSE, include=FALSE}
df_indicadores = dbGetQuery(con, sql_indicadores)
```

### 3.2.1 Tratamientos especiales

a) Variable `diferencia`

La variable `diferencia` fue creada a partir de la información microsimulada en tenencia, ya que dicha información representa la proporción con respecto del total de varios tipos de ocupación de una vivencia y para facilitar el análisis, se consolido únicamente en una variable que concentra los dos tipos de tenencia que se llevan la mayor proporción en las zonas censales: viviendas arrendadas y propias.

$$
diferencia = arrendada - propia
$$

Esta variable sintetiza el balance entre ambos tipos de tenencia por cada zona censal.

```{r indicador tenencia, echo=TRUE, message=FALSE, warning=FALSE}
zonas_gs_tenencia <- zonas_gs_tenencia %>% 
  mutate(diferencia = arrendada - propia)
```

b) Limpieza y ajuste

Al momento de analizar los datos, existía una zona censal con valores `NA` en la tenencia. Como este hecho se constituía exclusivamente para una zona, se opto por el siguiente método para imputar el dato: $x_{i}^{\text{ajustado}} =\begin{cases}x_{i}, & \text{si no es NA} \\\overline{x}_{\text{comuna}}, & \text{si es NA}\end{cases}$\
Es decir, los valores faltantes se reemplazaron por el promedio de las proporciones para la misma comuna, asumiendo que tienen características similares. Para casos donde sea mayor la cantidad de `NA's` se recomienda utilizar otros métodos, o bien, revisar la fiabilidad de este.

```{r uniones indicadores, message=FALSE, warning=FALSE, include=FALSE}
# 1. Unimos ingresos + indicadores 
zonas_gs_indicadores <- merge(
  zonas_gs_ingreso,
  df_indicadores[, c("geocodigo",
                     "promedio_escolaridad_18mas",
                     "promedio_personas_por_hogar")],
  by = "geocodigo",
  all.x = TRUE,
  all.y = FALSE
)

# 2. Unimos la columna 'diferencia' PERO sin geometría para evitar conflicto
zonas_gs_indicadores <- merge(
  zonas_gs_indicadores,
  st_drop_geometry(zonas_gs_tenencia)[, c("geocodigo", "diferencia")],
  by = "geocodigo",
  all.x = TRUE,
  all.y = FALSE
)


zonas_gs_indicadores <- zonas_gs_indicadores %>%
  group_by(nom_zona) %>%
  mutate(
    mediana_ingreso = ifelse(
      is.na(mediana_ingreso),
      mean(mediana_ingreso, na.rm = TRUE),
      mediana_ingreso
    ),
    promedio_escolaridad_18mas = ifelse(
      is.na(promedio_escolaridad_18mas),
      mean(promedio_escolaridad_18mas, na.rm = TRUE),
      promedio_escolaridad_18mas
    ),
    promedio_personas_por_hogar = ifelse(
      is.na(promedio_personas_por_hogar),
      mean(promedio_personas_por_hogar, na.rm = TRUE),
      promedio_personas_por_hogar
    )
  ) %>%
  ungroup()
```

```{r escalar variables, message=FALSE, warning=FALSE, include=FALSE}
vars_clusters = zonas_gs_indicadores[, c('diferencia',
                                         'mediana_ingreso',
                                         'promedio_escolaridad_18mas', 
                                         'promedio_personas_por_hogar')]

# Se elimina la geometría
vars_clusters$geometry = NULL

vars_clusters = na.omit(vars_clusters)

# Se escalan las variables
vars_scaled = scale(vars_clusters)
```

## 3.3 Método del Codo

```{r metodo del codo, echo=TRUE, message=FALSE, warning=FALSE}
fviz_nbclust(vars_scaled, kmeans, method = "wss") +
  labs(title = "Método del codo", x = "Número de clusters (k)", y = "WSS")
```

## 3.4 Clustering

```{r ejecutar k-means, echo=TRUE, message=FALSE, warning=FALSE}
set.seed(123)
km = kmeans(vars_scaled, centers = 4, nstart = 25)
```

```{r clusterDF, message=FALSE, warning=FALSE, include=FALSE}
zonas_gs_indicadores$cluster = as.factor(km$cluster)
```

# 4. Resultados y Análisis

## 4.1 Análisis Gráfico

### 4.1.1 Escolaridad vs Ingreso

```{r grafico1 esc vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = promedio_escolaridad_18mas,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Escolaridad (18+) v/s Ingreso",
    x = "Promedio años de escolaridad (>= 18 años)",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.2 Tamaño del hogar vs Ingreso

```{r grafico2 cantidad vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = promedio_personas_por_hogar,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tamaño del hogar v/s Ingreso",
    x = "Promedio personas por hogar",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.3 Tenencia vs Ingreso

```{r grafico3 tenencia vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = diferencia,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tenencia v/s Ingreso",
    x = "Diferencia % arrendada - % propia",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.4 Tenencia vs Escolaridad

```{r grafico4 tenencia vs esc, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = diferencia,
           y = promedio_escolaridad_18mas,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tenencia v/s Escolaridad (18+)",
    x = "Diferencia % arrendada - % propia",
    y = "Promedio años de escolaridad (>= 18 años)",
    color = "Cluster"
  ) +
  theme_minimal()
```

## 4.2 Estadísticas Generales

```{r estadisticas generales, echo=FALSE, message=FALSE, warning=FALSE}
datos_pairs <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%
  select(
    diferencia,
    mediana_ingreso,
    promedio_escolaridad_18mas,
    promedio_personas_por_hogar,
    cluster
  )

ggpairs(
  datos_pairs,
  columns = 1:4,  # solo las numéricas
  mapping = aes(color = cluster, alpha = 0.6)
)
```

## 4.3 Cartografía Clustering

```{r cartografia1 clusters, echo=FALSE, message=FALSE, warning=FALSE}
sql_comunas = "
SELECT cut, nom_comuna, geom
FROM dpa.comunas_rm_shp
WHERE nom_provin = 'SANTIAGO';
"


sf_comunas_santiago = st_read(con, query = sql_comunas)


# bbox del área urbana / zona de interés
bbox <- st_bbox(zonas_gs_indicadores)


mapa_clusters <- ggplot() +
  geom_sf(
    data  = zonas_gs_indicadores,
    aes(fill = cluster),
    color = "white",
    linewidth = 0.05
  ) +
  geom_sf(
    data  = sf_comunas_santiago,
    fill  = NA,
    color = "grey20",
    linewidth = 0.3
  ) +
  scale_fill_brewer(
    palette = "Set2",
    name    = "Cluster k-means"
  ) +
  coord_sf(
    xlim   = c(bbox["xmin"], bbox["xmax"]),
    ylim   = c(bbox["ymin"], bbox["ymax"]),
    expand = FALSE
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.background  = element_rect(fill = "white", color = NA),
    
    # Grilla REAL para mapas sf
    panel.grid.major = element_line(color = "grey85", linewidth = 0.3),
    panel.grid.minor = element_line(color = "grey93", linewidth = 0.2),
    
    legend.position  = "right",
    legend.title     = element_text(face = "bold"),
    legend.text      = element_text(size = 8),
    
    plot.title       = element_text(face = "bold", hjust = 0.5, size = 12),
    plot.subtitle    = element_text(hjust = 0.5, colour = "grey30", size = 9),
    plot.caption     = element_text(colour = "grey50", size = 7, hjust = 1)
  ) +
  labs(
    title    = "Clusters de zonas censales del Gran Santiago",
    subtitle = "k-means basado en ingreso, escolaridad, tamaño del hogar y tenencia",
    caption  = "Fuente: Censo 2017 (microdatos), elaboración propia"
  )

print(mapa_clusters)
```

```{r tabla clusters, echo=FALSE, message=FALSE, warning=FALSE}
tabla_clusters <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%      
  group_by(cluster) %>%
  summarise(
    ingreso              = mean(mediana_ingreso, na.rm = TRUE),
    escolaridad_18mas    = mean(promedio_escolaridad_18mas, na.rm = TRUE),
    personas_hogar       = mean(promedio_personas_por_hogar, na.rm = TRUE),
    diferencia_tenencia  = mean(diferencia, na.rm = TRUE),
    n_zonas              = dplyr::n()
  )

# 2) Reestructurar para plot tipo tabla
tabla_long <- tabla_clusters %>%
  pivot_longer(
    cols = -cluster,
    names_to = "variable",
    values_to = "valor"
  )

# 3) Plot tipo heatmap (tabla visual)
ggplot(tabla_long, aes(x = variable, y = factor(cluster), fill = valor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low  = "#2b8cbe",
    mid  = "white",
    high = "#e34a33",
    midpoint = median(tabla_long$valor, na.rm = TRUE),
    name = "Valor promedio"
  ) +
  geom_text(aes(label = round(valor, 2)), size = 3, color = "black") +
  labs(
    title = "Promedios por cluster",
    subtitle = "Ingreso, escolaridad, tamaño hogar, tenencia y número de zonas",
    x = "",
    y = "Cluster"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, colour = "grey40")
  )
```

## 4.4 Índice de Shannon

```{r cartografia2 shannon, echo=FALSE, message=FALSE, warning=FALSE}
sql_comunas = "
SELECT cut, nom_comuna, geom
FROM dpa.comunas_rm_shp
WHERE nom_provin = 'SANTIAGO'
   OR nom_comuna IN ('PUENTE ALTO', 'SAN BERNARDO');
"

sf_comunas_gs = st_read(con, query = sql_comunas)


# Aseguramos que cluster sea factor
zonas_gs_indicadores$cluster <- as.factor(zonas_gs_indicadores$cluster)

# Tabla comuna–cluster: cuántas zonas de cada cluster hay por comuna
tabla_comuna_cluster <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%
  group_by(nom_comuna, cluster) %>%
  summarise(
    n_zonas = dplyr::n(),
    .groups = "drop"
  )

# Índice de Shannon por comuna (NO normalizado)
tabla_shannon <- tabla_comuna_cluster %>%
  group_by(nom_comuna) %>%
  mutate(
    p = n_zonas / sum(n_zonas)
  ) %>%
  summarise(
    shannon              = -sum(p * log(p)),  # log natural
    n_total_zonas        = sum(n_zonas),
    n_clusters_efectivos = sum(p > 0),
    .groups = "drop"
  )

sf_comunas_shannon <- sf_comunas_gs %>%
  left_join(tabla_shannon, by = "nom_comuna")

# bbox desde tus zonas (ya incluye Puente Alto y San Bernardo)
bbox <- st_bbox(zonas_gs_indicadores)


mapa_shannon <- ggplot(sf_comunas_shannon) +
  geom_sf(
    aes(fill = shannon),
    color     = "grey85",
    linewidth = 0.2
  ) +
  geom_sf_text(
    data     = st_centroid(sf_comunas_shannon),
    aes(label = nom_comuna),
    size     = 2,
    fontface = "bold",
    colour   = "grey20"
  ) +
  scale_fill_gradient(
    low = "#e0f3db",
    high = "#0868ac",  # azul intenso
    name = "Índice de Shannon"
  ) +
  coord_sf(
    xlim   = c(bbox["xmin"], bbox["xmax"]),
    ylim   = c(bbox["ymin"], bbox["ymax"]),
    expand = FALSE
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.background   = element_rect(fill = "white", color = NA),
    panel.grid.major  = element_line(color = "grey90", linewidth = 0.3),
    panel.grid.minor  = element_line(color = "grey95", linewidth = 0.2),
    legend.position   = "right",
    legend.title      = element_text(face = "bold"),
    legend.text       = element_text(size = 8),
    plot.title        = element_text(face = "bold", hjust = 0.5, size = 12),
    plot.subtitle     = element_text(hjust = 0.5, colour = "grey30", size = 9),
    plot.caption      = element_text(colour = "grey50", size = 7, hjust = 1)
  ) +
  labs(
    title    = "Diversidad de clusters por comuna — Gran Santiago",
    subtitle = "Índice de Shannon (no normalizado)",
    caption  = "Fuente: Censo 2017 (microdatos), elaboración propia"
  )

print(mapa_shannon)
```

# 5. Conclusiones

# 6. Referencias
