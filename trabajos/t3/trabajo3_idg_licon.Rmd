---
title: "Caracterización de la población del Gran Santiago"
subtitle: "Clusters basados en tenencia de vivienda e ingresos"
author: "Kevin Licón Esparza"
date: "`r Sys.Date()`"
output: html_document
---

# 1. Introducción

::: {style="text-align: justify;"}
El presente trabajo se desarrolla como continuación directa del proceso iniciado en el Trabajo 2, donde se realizó una microsimulación con el propósito de estimar la tenencia de vivienda a nivel de zona censal en el Gran Santiago. Este ejercicio permitió generar una variable sintética a partir de la proporción de viviendas arrendadas y proporción de viviendas propias, construida a partir de microdatos del Censo 2017 y de la CASEN 2022.

En el marco de esta entrega, el trabajo tiene por objetivo utilizar dicha variable microsimulada como insumo principal para la aplicación de técnicas de agrupamiento. En particular, se implementa el algoritmo k-means con el fin de identificar conjuntos de zonas censales que compartan características similares. Para ello, además de la variable de tenencia generada previamente, se incorporan otras variables microsimuladas y, además, otras complementarias provenientes del Censo 2017.

Además de caracterizar la estructura interna de los grupos resultantes, este trabajo busca comparar el comportamiento de la variable microsimulada de tenencia con la combinación de variables seleccionada para el clustering. La intención es observar en qué medida la variable principal se alinea, se dispersa o adquiere nuevas formas de agrupamiento cuando es analizada junto a indicadores socioeconómicos complementarios.
:::

# 2. Objetivos

## 2.1 Objetivo General

::: {style="text-align: justify;"}
Aplicar técnicas de agrupamiento k-means para clasificar las zonas censales del Gran Santiago utilizando como insumo principal la variable de tenencia de vivienda microsimulada, incorporando variables complementarias del Censo 2017 para comparar su comportamiento conjunto.
:::

## 2.2 Objetivos Específicos

-   Integrar la variable microsimulada con los indicadores seleccionados y preparar la base para el análisis.

-   Determinar el número adecuado de clusters y ejecutar el algoritmo k-means sobre las variables estandarizadas.

-   Visualizar las relaciones entre las variables utilizadas y los clusters obtenidos.

-   Comparar la variable microsimulada con la estructura resultante del clustering.

# 3. Metodología

## 3.1 Librerías

::: {style="text-align: justify;"}
Para la realización del trabajo se utilizó como entorno de programación R (versión 4.5.1), complementado con un conjunto de librerías que permiten la conexión a bases de datos, manipulación de datos espaciales, microsimulación y visualización estadística.

```{r librerias, echo=TRUE, message=FALSE, warning=FALSE}
library(factoextra)
library(ggfortify)
library(plotly)
library(DBI)
library(RPostgres)
library(sf)
library(ggplot2)
library(cowplot)
library(GGally)
library(dplyr)
library(tidyr)
```

Estas herramientas permiten obtener un flujo de análisis más acabado.

## 3.2 Entradas

Para el desarrollo del análisis de utilizaron dos capas geoespaciales procesadas previamente y almacenadas en formato GeoJSON:

-   `zonas_gs_ingreso.geojson` : contiene la mediana de ingreso microsimulada por zona censal del Gran Santiago.

-   `zonas_gs_tenencia.geojson` : contiene las proporciones de tenencia de vivienda microsimulada por zona censal del Gran Santiago.

Ambas capas fueron importadas mediante la función `st_read()` del paquete **sf**. Además, se estableció una conexión con la base de datos PostgreSQL, desde la cual se extrajeron dos indicadores derivados del censo 2017.

```{r entradas, message=FALSE, warning=FALSE, include=FALSE}
zonas_gs_ingreso = st_read("../../output/zonas_gs_ingreso.geojson")
zonas_gs_tenencia = st_read("../../output/zonas_gs_tenencia.geojson")
```

```{r conexion DB, message=FALSE, warning=FALSE, include=FALSE}
## Conexión a BD

# Definir parámetros de conexión
db_host     = "localhost"       # servidor de BD
db_port     = 5432                # puerto de escucha
db_name     = "censo_rm_clases"   # nombre de la base
db_user     = "postgres"        # usuario de conexión
db_password = "postgres"        # clave de usuario

# Establecer conexión usando RPostgres
con = dbConnect(
  Postgres(),
  dbname   = db_name,
  host     = db_host,
  port     = db_port,
  user     = db_user,
  password = db_password
)
```

```{r Query extraccion, echo=TRUE, message=FALSE, warning=FALSE}
sql_indicadores = "
SELECT
  z.geocodigo AS geocodigo,
  c.nom_comuna,
  
  -- Años promedio de escolaridad para personas de 18+ años
  ROUND(
    AVG(p.escolaridad) FILTER (WHERE p.p09 >= 18 AND p.escolaridad IS NOT NULL),
    2) AS promedio_escolaridad_18mas,
  
  -- Promedio de personas por hogar en la zona
  ROUND(
    COUNT(*)::numeric
    / NULLIF(COUNT(DISTINCT h.hogar_ref_id), 0),
    2) AS promedio_personas_por_hogar

FROM public.personas   AS p
JOIN public.hogares    AS h ON p.hogar_ref_id    = h.hogar_ref_id
JOIN public.viviendas  AS v ON h.vivienda_ref_id = v.vivienda_ref_id
JOIN public.zonas      AS z ON v.zonaloc_ref_id  = z.zonaloc_ref_id
JOIN public.comunas    AS c ON z.codigo_comuna   = c.codigo_comuna

GROUP BY z.geocodigo, c.nom_comuna
ORDER BY promedio_escolaridad_18mas DESC;
"
```

Los indicadores obtenidos para cada zona censal a partir de la query fueron:

a) Promedio de escolaridad (18+)

Este indicador corresponde al promedio de los años de escolaridad reportados por las personas censadas que cumplen:

-   tener 18 años o más (variable `p09` $\geq$ 18).

-   poseer un valor no nulo en escolaridad.

La fórmula aplicada para cada zona censal $z$ es:

$$
\text{EscolaridadProm}_{z} =\frac{\sum_{i \in z,\, p09_i \ge 18} \text{escolaridad}_i}{N_{z,\;18+}}\
$$

donde $N_{z, 18+}$ es el número de personas mayores de edad en la zona. De aquí se obtiene la variable `promedio_scolaridad_18mas`.

b) Promedio de personas por hogar

El censo permite identificar hogares y sus integrantes. El indicador se construye como:

$$
\text{PersonasHogar}_{z} =\frac{N_{\text{personas},\,z}}{N_{\text{hogares},\,z}}
$$

Luego la variable es nombrada como `promedio_personas_por_hogar`.

```{r dataframe indicadores, message=FALSE, warning=FALSE, include=FALSE}
df_indicadores = dbGetQuery(con, sql_indicadores)
```

### 3.2.1 Tratamientos especiales

a) Variable `diferencia`

La variable `diferencia` fue creada a partir de la información microsimulada en tenencia, ya que dicha información representa la proporción con respecto del total de varios tipos de ocupación de una vivencia y para facilitar el análisis, se consolido únicamente en una variable que concentra los dos tipos de tenencia que se llevan la mayor proporción en las zonas censales: viviendas arrendadas y propias.

$$
diferencia = arrendada - propia
$$

Esta variable sintetiza el balance entre ambos tipos de tenencia por cada zona censal.

```{r indicador tenencia, echo=TRUE, message=FALSE, warning=FALSE}
zonas_gs_tenencia <- zonas_gs_tenencia %>% 
  mutate(diferencia = arrendada - propia)
```

b) Limpieza y ajuste

Al momento de analizar los datos, existía una zona censal con valores `NA` en la tenencia. Como este hecho se constituía exclusivamente para una zona, se opto por el siguiente método para imputar el dato: $x_{i}^{\text{ajustado}} =\begin{cases}x_{i}, & \text{si no es NA} \\\overline{x}_{\text{comuna}}, & \text{si es NA}\end{cases}$\
Es decir, los valores faltantes se reemplazaron por el promedio de las proporciones para la misma comuna, asumiendo que tienen características similares. Para casos donde sea mayor la cantidad de `NA's` se recomienda utilizar otros métodos, o bien, revisar la fiabilidad de este.

```{r uniones indicadores, message=FALSE, warning=FALSE, include=FALSE}
# 1. Unimos ingresos + indicadores 
zonas_gs_indicadores <- merge(
  zonas_gs_ingreso,
  df_indicadores[, c("geocodigo",
                     "promedio_escolaridad_18mas",
                     "promedio_personas_por_hogar")],
  by = "geocodigo",
  all.x = TRUE,
  all.y = FALSE
)

# 2. Unimos la columna 'diferencia' PERO sin geometría para evitar conflicto
zonas_gs_indicadores <- merge(
  zonas_gs_indicadores,
  st_drop_geometry(zonas_gs_tenencia)[, c("geocodigo", "diferencia")],
  by = "geocodigo",
  all.x = TRUE,
  all.y = FALSE
)


zonas_gs_indicadores <- zonas_gs_indicadores %>%
  group_by(nom_zona) %>%
  mutate(
    mediana_ingreso = ifelse(
      is.na(mediana_ingreso),
      mean(mediana_ingreso, na.rm = TRUE),
      mediana_ingreso
    ),
    promedio_escolaridad_18mas = ifelse(
      is.na(promedio_escolaridad_18mas),
      mean(promedio_escolaridad_18mas, na.rm = TRUE),
      promedio_escolaridad_18mas
    ),
    promedio_personas_por_hogar = ifelse(
      is.na(promedio_personas_por_hogar),
      mean(promedio_personas_por_hogar, na.rm = TRUE),
      promedio_personas_por_hogar
    )
  ) %>%
  ungroup()
```

```{r escalar variables, message=FALSE, warning=FALSE, include=FALSE}
vars_clusters = zonas_gs_indicadores[, c('diferencia',
                                         'mediana_ingreso',
                                         'promedio_escolaridad_18mas', 
                                         'promedio_personas_por_hogar')]

# Se elimina la geometría
vars_clusters$geometry = NULL

vars_clusters = na.omit(vars_clusters)

# Se escalan las variables
vars_scaled = scale(vars_clusters)
```

## 3.3 Método del Codo

Para determinar el número adecuado de clusters se aplicó el método del codo, utilizando como insumo las variables estandarizadas destinadas al agrupamiento:

-   diferencia (tenencia)

-   mediana de ingreso

-   promedio de escolaridad (18+)

-   promedio de personas por hogar

El método consiste en calcular la suma de cuadrados intra-cluster (WSS) para distintos valores *k*,observando el punto en el que la reducción de la inercia comienza a decrecer de manera notoria.

$$
\text{WSS}(k) = \sum_{j=1}^{k} \sum_{x_i \in C_j} \lVert x_i - \mu_j \rVert^{2}
$$

```{r metodo del codo, echo=TRUE, message=FALSE, warning=FALSE}
fviz_nbclust(vars_scaled, kmeans, method = "wss") +
  labs(title = "Método del codo", x = "Número de clusters (k)", y = "WSS")
```

De acuerdo con el resultado obtenido, el valor de *k* podría ser de 3 o 4. Al someter a prueba estos valores, se optó finalmente por generar 4 clusters, ya que generaba un mejor agrupamiento en gran parte de la ciudad.

## 3.4 Clustering

Para agrupar las zonas censales según sus características, se aplicó el algoritmo k-means utilizando las variables anteriormente mencionadas y posteriormente estandarizadas.

El algoritmo busca particionar las observaciones en *k* grupos de manera que cada zona quede asignada al cluster cuyo centroide sea el más cercano según distancia euclidiana. La partición seleccionada fue $k=4$, definida previamente mediante el método del codo.

```{r ejecutar k-means, echo=TRUE, message=FALSE, warning=FALSE}
set.seed(123)
km = kmeans(vars_scaled, centers = 4, nstart = 25)
```

El parámetro `nstart = 25` especifica que el algoritmo se inicializa 25 veces con centroides aleatorios, reteniendo la solución con menor suma de cuadrados intra-cluster.

```{r clusterDF, message=FALSE, warning=FALSE, include=FALSE}
zonas_gs_indicadores$cluster = as.factor(km$cluster)
```

# 4. Resultados y Análisis

## 4.1 Análisis Gráfico

### 4.1.1 Escolaridad vs Ingreso

El gráfico muestra cuatro agrupaciones bien definidas en el plano escolaridad-ingreso. El patrón más evidente es la separación vertical por niveles de ingreso, donde el cluster 2 concentra prácticamente todos los valores altos de ingreso y también los valores altos de escolaridad. En contraste, el cluster 4 se concentra en la zona de menor ingreso y menor escolaridad, formando una nube claramente diferenciada del resto.

Los cluster 1 y 3 aparecen en un rango intermedio, pero no se superponen totalmente: el cluster 3 ocupa un tramo más amplio de escolaridad, don una dispersión mayor en ingreso. Mientras que el cluster 1 se mantiene más acotado en ambos ejes.

```{r grafico1 esc vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = promedio_escolaridad_18mas,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Escolaridad (18+) v/s Ingreso",
    x = "Promedio años de escolaridad (>= 18 años)",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.2 Tamaño del hogar vs Ingreso

La relación entre el promedio de personas por hogar y el ingreso presenta una separación que, en algunos casos, no resulta tan clara, donde nuevamente existe una tendencia vertical frente al ingreso. El cluster 2 vuelve a concentrase en los valores altos de ingreso y, al mismo tiempo, en los tamaños de hogar más bajos dentro del rango observado. En el extremo opuesto, el cluster 4 agrupa la mayoría de las zonas con ingresos bajos y una mayor variación en el tamaño del hogar, incluyendo algunos valores atípicos muy altos.

Los cluster 1 y 3 se distribuyen en la parte inferior del gráfico, con tamaños de hogar similares, pero diferenciándose por nivel de ingreso. Es posible que la escala escogida para el promedio de personas por hogar no permita observar mejor las agrupaciones, ya que en general se encuentran en valores cercanos similares.

```{r grafico2 cantidad vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = promedio_personas_por_hogar,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tamaño del hogar v/s Ingreso",
    x = "Promedio personas por hogar",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.3 Tenencia vs Ingreso

La variable de tenencia (diferencia arrendada - propia) muestra un comportamiento claramente segmentado según los clusters. El cluster 1 concentra valores positivos y altos, lo que indica que en estas zonas la proporción de viviendas arrendadas supera ampliamente a la de viviendas propias. Esta característica se combina con ingresos intermedios, formando un grupo que se distingue tanto por su posición horizontal como por su consistencia vertical.

El tramo central cercano a cero esta dominado por el cluster 2, cuyas zonas combinan una tenencia más equilibrada con los ingresos más altos del conjunto. Este comportamiento sugiere que, dentro de esta combinación de variables, las zonas de mayor ingreso no se asocian a una predominancia marcada de arriendo o propiedad, sino de valores de tenencia más neutros.

Los cluster 3 y 4 ocupan principalmente el tramo negativo de tenencia. Esto muestra que estas zonas la proporción de vivienda propia es mayor que la de arriendo. Dentro de este grupo, el cluster 3 se asocia a ingresos intermedios, mientras el cluster 4 concentra ingresos más bajos, lo que genera una distinción vertical entre ambos.

```{r grafico3 tenencia vs ingreso, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = diferencia,
           y = mediana_ingreso,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tenencia v/s Ingreso",
    x = "Diferencia % arrendada - % propia",
    y = "Mediana de ingreso",
    color = "Cluster"
  ) +
  theme_minimal()
```

### 4.1.4 Tenencia vs Escolaridad

La variable de tenencia vuelve a generar una separación horizontal clara entre los clusters. El cluster 1 se ubica en el extremo positivo, con valores de niveles de escolaridad moderados, lo que muestra que el predominio del arriendo en este grupo no está asociado a valores extremos de escolaridad.

En el tramo central cercano a cero se concentra el cluster 2, que coincide con los valores más altos de escolaridad del conjunto. Su posición sugiere que las zonas con mayor escolaridad no se alinean con un patrón marcado de arriendo o propiedad, sino que se mantiene en valores más equilibrados.

Los clusters 3 y 4 mantienen diferencia negativa, asociándose a zonas donde la proporción de vivienda propia es mayor. Entre ellos, la separación se produce principalmente en el eje vertical dado por los ingresos. Esta distinción indica que, aun compartiendo un patrón similar de tenencia, ambos grupos muestras distribuciones distintas de escolaridad.

```{r grafico4 tenencia vs esc, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(zonas_gs_indicadores,
       aes(x = diferencia,
           y = promedio_escolaridad_18mas,
           color = cluster)) +
  geom_point(size = 2) +
  labs(
    title = "Tenencia v/s Escolaridad (18+)",
    x = "Diferencia % arrendada - % propia",
    y = "Promedio años de escolaridad (>= 18 años)",
    color = "Cluster"
  ) +
  theme_minimal()
```

## 4.2 Estadísticas Generales

La matriz muestra correlaciones calculadas tanto para el conjunto completo como para cada cluster por separado. a nivel general, aparecen tres relaciones particularmente destacables:

1.  Tenencia vs Personas por hogar (corr = -0,514): la correlación negativa indica que, en conjunto, las zonas con mayor predominio de vivienda propia tienden a presentar tamaños de hogar más alto. La magnitud de la correlación es una de las más fuertes.
2.  Ingreso vs Personas por hogar (corr = -0,382): también negativa y relativamente fuerte, sugiere que los ingresos medianos más altos se asocian numéricamente con hogares de menor tamaño.
3.  Escolaridad vs Personas por hogar (corr = -0,461): la relación negativa confirma que el aumento en los promedios de escolaridad se acompaña de una reducción del tamaño del hogar. Otras de las correlaciones generales de mayor magnitud.

En cuanto a los patrones específicos por cluster, hay valores que llaman la atención por su magnitud o por diferenciarse del comportamiento general:

-   En el cluster 1, la correlación entre ingreso y tenencia es notablemente más alta que en el total. Esto muestra que, dentro de este grupo, el ingreso sí juega un rol relevante en la variación de la variable microsimulada de tenencia. Dado que este cluster reúne zonas con ingresos bajos y predominio del arriendo, la relación más intensa entre ambas variables sugiere que en este segmento particular el nivel de ingreso está mucho más vinculado a la estructura de tenencia que en el resto del conjunto.

```{r estadisticas generales, echo=FALSE, message=FALSE, warning=FALSE}
datos_pairs <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%
  select(
    diferencia,
    mediana_ingreso,
    promedio_escolaridad_18mas,
    promedio_personas_por_hogar,
    cluster
  )

ggpairs(
  datos_pairs,
  columns = 1:4,  # solo las numéricas
  mapping = aes(color = cluster, alpha = 0.6)
)
```

## 4.3 Cartografía Clustering

```{r cartografia1 clusters, echo=FALSE, message=FALSE, warning=FALSE}
sql_comunas = "
SELECT cut, nom_comuna, geom
FROM dpa.comunas_rm_shp
WHERE nom_provin = 'SANTIAGO';
"


sf_comunas_santiago = st_read(con, query = sql_comunas)


# bbox del área urbana / zona de interés
bbox <- st_bbox(zonas_gs_indicadores)


mapa_clusters <- ggplot() +
  geom_sf(
    data  = zonas_gs_indicadores,
    aes(fill = cluster),
    color = "white",
    linewidth = 0.05
  ) +
  geom_sf(
    data  = sf_comunas_santiago,
    fill  = NA,
    color = "grey20",
    linewidth = 0.3
  ) +
  scale_fill_brewer(
    palette = "Set2",
    name    = "Cluster k-means"
  ) +
  coord_sf(
    xlim   = c(bbox["xmin"], bbox["xmax"]),
    ylim   = c(bbox["ymin"], bbox["ymax"]),
    expand = FALSE
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.background  = element_rect(fill = "white", color = NA),
    
    # Grilla REAL para mapas sf
    panel.grid.major = element_line(color = "grey85", linewidth = 0.3),
    panel.grid.minor = element_line(color = "grey93", linewidth = 0.2),
    
    legend.position  = "right",
    legend.title     = element_text(face = "bold"),
    legend.text      = element_text(size = 8),
    
    plot.title       = element_text(face = "bold", hjust = 0.5, size = 12),
    plot.subtitle    = element_text(hjust = 0.5, colour = "grey30", size = 9),
    plot.caption     = element_text(colour = "grey50", size = 7, hjust = 1)
  ) +
  labs(
    title    = "Clusters de zonas censales del Gran Santiago",
    subtitle = "k-means basado en ingreso, escolaridad, tamaño del hogar y tenencia",
    caption  = "Fuente: Censo 2017 (microdatos), elaboración propia"
  )

print(mapa_clusters)
```

El mapa muestra la distribución espacial de los cuatro clusters obtenidos mediante k-means, aplicados únicamente sobre las variables de estudio. Es posible observar que existe una tendencia en cuanto a la distribución de los clusters. Para el cluster 1, se tiene que se concentra en la zona central del Gran Santiago, lo que en cuanto a la microsimulación realizada para la tenencia, se había observado que en este sector se daba la mayor proporción de arriendo, lo que podría ser un factor clave al realizar el cluster. En cuanto al resto, sigue una tendencia progresiva en torno al centro, distribuyéndose similar a la microsimulación, pero en este caso aparece una zona especial con el cluster 2, que se diferencia del resto. Esta zona corresponde al sector oriente de la capital, el cual es asociado a sectores de mayores ingresos.

```{r tabla clusters, echo=FALSE, message=FALSE, warning=FALSE}
tabla_clusters <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%      
  group_by(cluster) %>%
  summarise(
    ingreso              = mean(mediana_ingreso, na.rm = TRUE),
    escolaridad_18mas    = mean(promedio_escolaridad_18mas, na.rm = TRUE),
    personas_hogar       = mean(promedio_personas_por_hogar, na.rm = TRUE),
    diferencia_tenencia  = mean(diferencia, na.rm = TRUE),
    n_zonas              = dplyr::n()
  )

# 2) Reestructurar para plot tipo tabla
tabla_long <- tabla_clusters %>%
  pivot_longer(
    cols = -cluster,
    names_to = "variable",
    values_to = "valor"
  )

# 3) Plot tipo heatmap (tabla visual)
ggplot(tabla_long, aes(x = variable, y = factor(cluster), fill = valor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low  = "#2b8cbe",
    mid  = "white",
    high = "#e34a33",
    midpoint = median(tabla_long$valor, na.rm = TRUE),
    name = "Valor promedio"
  ) +
  geom_text(aes(label = round(valor, 2)), size = 3, color = "black") +
  labs(
    title = "Promedios por cluster",
    subtitle = "Ingreso, escolaridad, tamaño hogar, tenencia y número de zonas",
    x = "",
    y = "Cluster"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, colour = "grey40")
  )
```

A partir de la información presentada en la tabla se han clasificado los clusters de la siguiente manera:

a) Cluster 1: "Zonas urbanas de clase media profesional con alta presencia de arriendo"

Este grupo reúne las zonas de ingresos medios y elevados niveles educativos, pero con una característica distintiva en cuanto al dominio de arriendo como forma de ocupación de vivienda. Corresponde a sectores densos, centrales y bien conectados de la ciudad, en el caso particular de la cartografía obtenida, comunas como Santiago Centro e Independencia.

b) Cluster 2: "Zonas de élite socioeconómica de alta consolidación"

Este grupo concentra las zonas con valores más altos de ingreso y escolaridad del conjunto metropolitano. Corresponde territorialmente a los sectores del oriente metropolitano: Providencia, Ñuñoa, Vitacura y Las Condes.

c) Cluster 3: "Zonas residenciales de clase media con estructuras familiares mayores"

Este caso refleja las zonas de ingreso medio-bajo, con escolaridad moderada y un tamaño de hogar relativamente más elevado. La vivienda propia predomina, aunque no de manera tan marcada como en el cluster 4. Se asocia a territorios de clase media familiar. No hay comunas marcadas con este cluster, sino que se asocia a barrios o sectores dentro de las comunas.

d) Cluster 4: "Zonas populares tradicionales de baja renta y hogares grandes"

Este corresponde al grupo de menor nivel socioeconómico del conjunto. Si bien se distribuye similar al cluster 3 en el territorio, hay una leve tendencia donde el cluster 4 aparece más que el cluster 3 en el sector poniente del área metropolitana.

## 4.4 Índice de Shannon

El índice de Shannon se utilizó para medir cuán diversa es la composición de clusters dentro de cada comuna. Su valor aumenta cuando una comuna contiene varios clusters con proporciones similares entre sí, y disminuye cuando la presencia de clusters es más homogénea o dominada por uno solo.

```{r cartografia2 shannon, echo=FALSE, message=FALSE, warning=FALSE}
sql_comunas = "
SELECT cut, nom_comuna, geom
FROM dpa.comunas_rm_shp
WHERE nom_provin = 'SANTIAGO'
   OR nom_comuna IN ('PUENTE ALTO', 'SAN BERNARDO');
"

sf_comunas_gs = st_read(con, query = sql_comunas)


# Aseguramos que cluster sea factor
zonas_gs_indicadores$cluster <- as.factor(zonas_gs_indicadores$cluster)

# Tabla comuna–cluster: cuántas zonas de cada cluster hay por comuna
tabla_comuna_cluster <- zonas_gs_indicadores %>%
  st_drop_geometry() %>%
  group_by(nom_comuna, cluster) %>%
  summarise(
    n_zonas = dplyr::n(),
    .groups = "drop"
  )

# Índice de Shannon por comuna (NO normalizado)
tabla_shannon <- tabla_comuna_cluster %>%
  group_by(nom_comuna) %>%
  mutate(
    p = n_zonas / sum(n_zonas)
  ) %>%
  summarise(
    shannon              = -sum(p * log(p)),  # log natural
    n_total_zonas        = sum(n_zonas),
    n_clusters_efectivos = sum(p > 0),
    .groups = "drop"
  )

sf_comunas_shannon <- sf_comunas_gs %>%
  left_join(tabla_shannon, by = "nom_comuna")

# bbox desde tus zonas (ya incluye Puente Alto y San Bernardo)
bbox <- st_bbox(zonas_gs_indicadores)


mapa_shannon <- ggplot(sf_comunas_shannon) +
  geom_sf(
    aes(fill = shannon),
    color     = "grey85",
    linewidth = 0.2
  ) +
  geom_sf_text(
    data     = st_centroid(sf_comunas_shannon),
    aes(label = nom_comuna),
    size     = 2,
    fontface = "bold",
    colour   = "grey20"
  ) +
  scale_fill_gradient(
    low = "#e0f3db",
    high = "#0868ac",  # azul intenso
    name = "Índice de Shannon"
  ) +
  coord_sf(
    xlim   = c(bbox["xmin"], bbox["xmax"]),
    ylim   = c(bbox["ymin"], bbox["ymax"]),
    expand = FALSE
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.background   = element_rect(fill = "white", color = NA),
    panel.grid.major  = element_line(color = "grey90", linewidth = 0.3),
    panel.grid.minor  = element_line(color = "grey95", linewidth = 0.2),
    legend.position   = "right",
    legend.title      = element_text(face = "bold"),
    legend.text       = element_text(size = 8),
    plot.title        = element_text(face = "bold", hjust = 0.5, size = 12),
    plot.subtitle     = element_text(hjust = 0.5, colour = "grey30", size = 9),
    plot.caption      = element_text(colour = "grey50", size = 7, hjust = 1)
  ) +
  labs(
    title    = "Diversidad de clusters por comuna — Gran Santiago",
    subtitle = "Índice de Shannon (no normalizado)",
    caption  = "Fuente: Censo 2017 (microdatos), elaboración propia"
  )

print(mapa_shannon)
```

En el mapa, se observan comuna con valores relativamente altos del índice, lo que indica una distribución más equilibrada de los distintos clusters en ella. En contraste, las comunas con valores más bajos presentan una estructura interna más uniforme. Algunos valores del índice pueden estar sesgados ya que en la comuna existía presencia de un solo cluster.

# 5. Conclusiones

El análisis permitió identificar cuatro clusters con perfiles numéricos claramente diferenciados a partir de la variable de tenencia microsimulada y de los indicadores censales utilizados. La segmentación obtenida mostró coherencia interna y evidenció que las combinaciones de ingreso, escolaridad, tamaño del hogar y tenencia generan estructuras estables dentro del conjunto de zonas censales.

La comparación entre correlaciones generales y por cluster reveló que algunas relaciones como ingreso y tenencia, o escolaridad y tamaño del hogar, adquieren comportamientos distintos según el grupo, lo que confirma la existencia de patrones heterogéneos que no se observan al analizar el total de zonas como un único conjunto. La cartografía y el índice de Shannon complementaron este resultado al mostrar cómo estos patrones se distribuyen y mezclan dentro de los límites comunales.

El valor del estudio radica en que la metodología utilizada ofrece una base operativa para agrupar zonas con comportamientos similares, lo que puede resultar útil en distintos ámbitos de trabajo. La clasificación obtenida podría emplearse en tareas de segmentación territorial previa a estudios urbanos, en diagnósticos que requieran identificar áreas con perfiles sociohabitacionales comparables, o en la focalización inicial de intervenciones públicas o privadas, donde se necesite distinguir zonas con características homogéneas antes de aplicar análisis más detallados. Asimismo, los clusters pueden servir como unidades de análisis intermedio para investigaciones que busquen simplificar la heterogeneidad del territorio sin recurrir a divisiones administrativas tradicionales.

# 6. Referencias

Centro de Estudios MINVU. (2022). *Informe de Mercado de Suelo Urbano y Vivienda: Región Metropolitana*. Ministerio de Vivienda y Urbanismo, Gobierno de Chile.

Fuentes, L., & Hernández, A. (2021). *Transformaciones del mercado del arriendo y nuevas dinámicas residenciales en Santiago de Chile*. Instituto de Estudios Urbanos y Territoriales, Pontificia Universidad Católica de Chile.
:::
